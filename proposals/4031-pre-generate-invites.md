# MSC-4031: Pre-generating invites for future redemption


## Introduction

Currently, onboarding users to the Matrix Fediverse has more points of friction than its peers.  The timeline for an existing Matrix user to on-board a new user to their space, and/or room by extension, is significantly longer than what it could be from the invitee's perspective:


> 1. Ask friend to join matrix/homeserver
> 2. They make an account on a homeserver
> 3. They give you their username
> 4. You invite them to private room/space
> 5. They manually accept invite
> 6. They join your room/space

Versus the flow for onboarding an invitee in other services, and what this MSC aims to introduce into Matrix:

> 1. Ask friend to join matrix/homeserver 
> 2. They make an account on a homeserver
> 3. Hand them invite code/link
> 4. They join your room/space

Where in the improved flow, there is no necessity for exessive back-and-forth between the inviter and invitee. With pre-generated invites, points 1 and 3 could realistically be condensed into a single event from the invitee's point of view.


## Proposal

### New room state event

Create a new `m.room.invite` event.


| Event Type | State Event             |
| ---------- | ----------------------- |
| State key  | A random case sensitive ASCII string |


##### Content

| Name       | Type    | Description                                                                                                 |
| ---------- | ------- | ----------------------------------------------------------------------------------------------------------- |
| created_by | string  | The fully qualified ID of the user who made the invite                                                      |
| not_after  | integer | The expiration date of the invite. Set to `-1` to indicate no expiry until manual redaction. Timestamp (in milliseconds since the unix epoch) on originating homeserver when this event was sent.              |
| good_for   | integer | The amount of uses the invite event has remaining, Set to `-1` to indicate no expiry until manual redaction |
| uses       | integer | Number of times the invite has been used.                                                                   |
| hash       | string  | The hash of the private key used to verify the user can use the invite.                                     |


If `good_for` is greater than or equal to 1, it *must* be decremented each time a user is accepted using a given invite.

If `good_for` is currently 0 or has just been decremented to 0, it *must* be redacted by the server.

Example:
```json
{
	"event_id": "$event_id",
	"type": "m.room.invite",
	"state_key": "MwhqK12Rs4",

	"content": {
		"created_by": "@example:example.org",
		"not_after": "expiration date",
		"good_for": 6,
		"uses": 3,
		"hash": "aac88f2747be898998cb3d2793e2d71a93bb4902fd77de507bd0e8ee92e5b05f"
		
	}
}
```

This example is using a sha-265 hash of the string `inviteme!` for the hash. 

A user attempted to join a room via providing a secret will have it hashed and compared against the stored hash to determine if they may use the specific invite room event to join.

The burden of remembering the secret key will be on the person who created the invite, however this is acceptable as clients could generate an extended room ID with the state key and provided/generated secret.

### Extend the room URI when using inline invite keys

Currently room uris take the form of `[string]:[server_name]`, and they could be extended to:

`[string]:[server_name]#[state_key]/[secret_key]` so that a client can interpret the state and secret keys from the URI and allow a join request to be made with the identifying information needed for the homeserver to add the user to the room's member list.
Optionally clients could also ask a user for a state_key and secret key when one or both is not provided, and the room they are are attempting to join is rejecting their join request. 

For example, the following invite URI could be generated by a user's client:

```
!irs2iosct:example.com#MwhqK12Rs4/inviteme!
```

and subsequently handed over to a https://matrix.to or equivalent redirection service to create clickable links such as:
[`https://matrix.to/#/!irs2iosct:example.com#MwhqK12Rs4/inviteme!`](https://matrix.to/#/!irs2iosct:example.com#MwhqK12Rs4/inviteme!) (This link goes nowhere)

While not as pretty as some of Matrix's peers' invite urls, it would fulfill the basic function of allowing a user to join a private room without have their specific user account explicitly invited to participate.

### Extend the `m.room.power_levels` state event

Add new content items for managing and creating invites.

##### Content

| Name           | Type    | Description                                                           |
| -------------- | ------- | --------------------------------------------------------------------- |
| create_invites  | integer | The level required to create invites for the room.                    |
| manage_invites | integer | The level required to list and manage invites created by other users. |

### New API endpoints to get room invites

Ideally, invites *should not* be exposed by the [`/_matrix/client/v3/rooms/{roomId}/state`](https://spec.matrix.org/v1.7/client-server-api/#get_matrixclientv3roomsroomidstate) endpoint *unless* the requesting user has the power level required to list invites. Any invites created by the requesting user *should* be returned, regardless of the user's power level. It is assumed that a user with invites has, or had the power level required to create their own invites, so they should remain accessible to them until they expire or a higher power user manually redacts them.


New endpoint:

#### **GET** `/_matrix/client/v3/rooms/{roomId}/invites`

Get the invites created for a room. This endpoint should be restricted by a user's power level in a room to prevent leaking invite keys to default or lower power members in a restricted room. 

| Rate-limited            | No  |
| ----------------------- | --- |
| Requires Authentication | Yes |

##### Request

| path parameters | Type     | Description                                      |
| --------------- | -------- | ------------------------------------------------ |
| roomId          | `string` | **Required:** The room to look up the state for. |

##### Responses

| Status | Description                                                                  |
| ------ | ---------------------------------------------------------------------------- |
| 200    | The list of all invites created                                              |
| 403    | You aren’t a member of the room and weren’t previously a member of the room. |
| 403    | You dont have sufficient power for this request                              |

###### 200 Response

Array of [`ClientEvent`](https://spec.matrix.org/v1.7/client-server-api/#room-event-format)

If a user has sufficient power to list either their own invites, or that of other users, but none exist, respond with an empty array.


###### 403 Response

| Error   |        |                                |
| ------- | ------ | ------------------------------ |
| Name    | Type   | Description                    |
| errcode | string | An error code                  |
| error   | string | A human-readable error message |

```json
{
	"errrcode": "M_NOPOWER",
	"error": "Insufficient permissions to list invites"
}
```




### Extend the Server-Server `send_join` 

#### [`PUT /_matrix/federation/v2/send_join/{roomId}/{eventId}`](https://spec.matrix.org/v1.7/server-server-api/#put_matrixfederationv2send_joinroomideventid)

Add extra content fields to allow a user submit their *state_key* and *secret key* in order to use and invite and join.

###### Membership Event Content

| Name       | Type   | Description                                                               |
| ---------- | ------ | ------------------------------------------------------------------------- |
| invite_key | string | The `state_key` of the invite event the resident server should look for.  |
| secret_key | string | The secret key the resident server should verify matches the stored hash. |


```json
{
  "content": {
    "membership": "join",
    "invite_key": "MwhqK12Rs4",
    "secret_key": "inviteme!"
  },
  "origin": "matrix.org",
  "origin_server_ts": 1234567890,
  "sender": "@someone:example.org",
  "state_key": "@someone:example.org",
  "type": "m.room.member"
}
```



### Extend the Client-Server `/rooms/{roomId}/join`

[`POST /_matrix/client/v3/rooms/{roomId}/join`](https://spec.matrix.org/v1.7/client-server-api/#post_matrixclientv3roomsroomidjoin)

Create another optional block for when the user has provided the necessary information to join a room via pre-generated invite code, modeled after the existing *Third-party Signed* block.


| Pre-generated key |        |                                                               |
| ----------------- | ------ | ------------------------------------------------------------- |
| Name              | Type   | Description                                                   |
| token             | string | **Required** State key of the m.room.invite event to find     |
| secret_key        | string | **Required** The secret key for the resident server to verify |


### Update room authorization rules

Adding a new rule to the [Room Version 10](https://spec.matrix.org/v1.7/rooms/v10/#authorization-rules) rules.



4. If type is `m.room.member`:
	1.  ....
	2.  ...
	3.  if `membership` is `join`:
		1. ...  
		2. ...  
		3. If the `sender` is banned, reject.
		4.  **\[New in this MSC]** If there a *state_key* and *secret key* are provided
			1. If a `m.room.invite` with the supplied *state key* cannot be found, reject
			2. If an invite event with the supplied state key is found
				1. If the hash of the supplied *secret key* does not match the stored invite *hash*, reject
				2. If the *not_after* date is less than the current unix timestamp, reject
				3. If the hash of the *secret key* and stored *hash* match, allow.
		5. 
		6. ...
		7. ...
		8. ...
		9. ...
		10. Otherwise, reject

...

10. **\[New in this MSC]** If type is `m.room.invite`:
	1. If there are no previous `m.room.invite`s in the room with the same *state_key*
		1.  If the `sender`'s power level is greater than or equal to *create invites*, allow



## Potential issues

*Not all proposals are perfect. Sometimes there's a known disadvantage to implementing the proposal,
and they should be documented here. There should be some explanation for why the disadvantage is
acceptable, however - just like in this example.*

Someone is going to have to spend the time to figure out what the template should actually have in it.
It could be a document with just a few headers or a supplementary document to the process explanation,
however more detail should be included. A template that actually proposes something should be considered
because it not only gives an opportunity to show what a basic proposal looks like, it also means that
explanations for each section can be described. Spending the time to work out the content of the template
is beneficial and not considered a significant problem because it will lead to a document that everyone
can follow.


## Alternatives

### Generate and store invites differently

Much of the complexity arises from storing, authenticating and transmitting invites while trying to minimize new additions. Alternatively invites could be removed entirely from the event history and put directly in the database of the resident homeserver, as well as allow powerful room members to request an invite code and generate a url directly from the resident homeserver.

Instead of URIs that look like `!irs2iosct:example.com#MwhqK12Rs4/inviteme!` as proposed by the MSC, this could instead yield much prettier urls such as `https://invite.example.com/invitecode` and cleaner invite codes like `invitecode:example.com`

A stopgap between these two could be an integration or extension of homeserver services that serves as a url shortener such as bit.ly, to avoid needing a deeper rewrite of the spec while maintaining url readability of Matrix's competitor.


## Security considerations


### Unintentionally leaking the secret key

The method of authenticating an invite code here would expose the raw *secret key* to a user's homeserver and possibly the redirection service used by a user's client. Specifically this may expose *secret key*s to [https://matrix.to](https://matrix.to) as it is Element's default url redirector.

Since it is unavoidable to expose the secret key to a user's personal homeserver, it will be assumed a user's homeserver is trusted. 

In this case, a remedy to this issue would allowing the user's homeserver to define a something along the lines of a `redirection_provider` in the `.well-known/matrix/client` that overrides the client's default redirection service. This way an invitee would have to intentionally attach the invite credentials to an untrusted redirection provider.

Alternatively the process of generating valid invite links (not invite codes) could be offloaded to the resident homeserver itself. See alternatives above.



## Dependencies

This MSC has no known dependencies