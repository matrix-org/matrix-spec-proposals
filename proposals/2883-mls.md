# MSC2883: [WIP] Matrix-flavoured MLS

[Messaging Layer Security (MLS)](https://messaginglayersecurity.rocks/) is
[IETF standard](https://datatracker.ietf.org/doc/rfc9420/) for end-to-end
encryption in group chats.  [Decentralised
MLS](https://gitlab.matrix.org/matrix-org/mls-ts/-/blob/decentralised2/decentralised.org)
(DMLS) is a variant of MLS that allows it to operate in a decentralised
environment.  This MSC outlines how DMLS can be used in Matrix.

\[**WARNING:** this is very much a work in progress, mainly in the braindump
stage.  It may or may not be coherent.\]

## Proposal

Note: whenever base64-encoding is mentioned in this proposal, the encoding
should be unpadded (without any `=` at the end).

### Ciphersuite

MLS defines several ciphersuites that can be used, and allows implementation to
define their own private-use suites.  The mandatory-to-implement ciphersuite in
MLS uses Ed25519, X25519, AES-128-GCM, and HKDF-SHA-256, which closely matches
what is currently used in Matrix.  The main difference is it uses AES-128-GCM
instead of AES-256-CBC/CTR.

We will identify the ciphersuite used in algorithm names, for example,
`m.dmls.v1.dhkemx25519-aes128gcm-sha256-ed25519`.

\[TODO: In addition to the mandatory-to-implement ciphersuite, we may want to
consider the ciphersuites that use Ed448 and/or ChaCha20-Poly1305. (cf.
https://github.com/matrix-org/matrix-doc/issues/2458 ) Or should we say that
any MLS ciphersuite is allowed, but warn that not all clients will support all
of them?  For now, we just define the identifiers for the
mandatory-to-implement ciphersuite.\]

### Credentials

In MLS, each device has a
[credential](https://messaginglayersecurity.rocks/mls-protocol/draft-ietf-mls-protocol.html#name-credentials)
that identifies the device and associates a public signing key with the device.
In Matrix, since we rely on out-of-band verification, we can use basic
credentials.

\[TODO: we need to define a format for Basic credentials now - earlier drafts
defined a format, but the latest draft leaves it up to the application.  We'll
want the credential to include the user ID, device ID, and the signing key.

NOTE: the current trial implementation is based on an MLS implementation of an
earlier draft, so the credential identifier is a concatenation of the user ID
and device ID, separated by a `|`.\]

A device's MLS credential is included in the device keys uploaded to [`POST
/keys/upload`](https://spec.matrix.org/unstable/client-server-api/#post_matrixclientv3keysupload)
by including an `m.dmls.v1.credential.[signature_algorithm]:[device_id]`
property in the `keys` property, where `[signature_algorithm]` indicates the
signature algorithm (e.g. `ed25519`), and the device key object must be signed
with the credential's signing key, using [signed
JSON](https://spec.matrix.org/unstable/appendices/#signing-json).  The client
must also include `m.dmls.v1.[ciphersuite]` in the `algorithms` property.

For example:

`POST /v3/device/upload`
```json
{
  "device_keys": {
    "algorithms": [
      "m.olm.v1.curve25519-aes-sha2",
      "m.megolm.v1.aes-sha2",
      "m.dmls.v1.dhkemx25519-aes128gcm-sha256-ed25519"
    ],
    "device_id": "JLAFKJWSCS",
    "keys": {
      "curve25519:JLAFKJWSCS": "3C5BFWi2Y8MaVvjM8M22DBmh24PmgR0nPvJOIArzgyI",
      "ed25519:JLAFKJWSCS": "lEuiRJBit0IG6nUf5pUzWTUEsRVVe/HJkoKuEww9ULI",
      "m.dmls.v1.credential.ed25519:JLAFKJWSCS": "some+mls+credential"
    },
    "signatures": {
      "@alice:example.com": {
        "ed25519:JLAFKJWSCS": "dSO80A01XiigH3uBiDVx/EjzaoycHcjq9lfQX0uWsqxl2giMIiSPR8a4d291W1ihKJL/a+myXS367WT6NAIcBA",
        "m.dmls.v1.credential.ed25519:JLAFKJWSCS": "a+signature"
      }
    },
    "user_id": "@alice:example.com"
  }
}
```

Although Olm and MLS can use the same signature algorithm, we do not use the
same key for both as they may be implemented by different libraries, and it may
be difficult to use a key generated in one library in another library.

### Enabling encryption

A room will have MLS enabled by including an `encryption` property in its
`m.room.create` event.  This property must be an object with an `algorithm`
property set to `m.dmls.v1.[ciphersuite]`, where `[ciphersuite]` is a string
identifying the ciphersuite used.  MLS's mandatory-to-implement ciphersuite,
`MLS_128_DHKEMX25519_AES128GCM_SHA256_Ed25519`, is identified by the string
`dhkemx25519-aes128gcm-sha256-ed25519`.  Any `m.room.encryption` event in the
room with a different `algorithm` is ignored.

Note that by putting the encryption algorithm in the `m.room.create` event,
this means that the encryption algorithm cannot change.  That is, a room cannot
change from using Megolm to using MLS, or vice versa.  In order to change
encryption algorithms, users will need to create a new room, for example by
performing a "room upgrade".

\[TODO: should we add parameters, e.g. for how often `UpdatePath`s should be
sent?  Can these parameters be changed? e.g. we could use `m.room.encryption`
to set these parameters.\]

If there are other devices in the room at the time of creation, the room
creator should update the MLS group to add these devices, as defined below.  If
there are no other devices, the room creator must still send an event to the
room giving the public group state.  It can do this by either sending an empty
commit and updating the MLS group as defined below, or by sending an event of
the form:

```json
{
  "algorithm": "m.dmls.v1.[ciphersuite]",
  "ciphertext": "",
  "epoch_creator": ["<user ID>", "<device ID>"],
  "sender": ["<user ID>", "<device ID> "],
  "resolves": [],
  "commit_event": "<event ID for the m.room.create event>",
  "public_group_state": "<base64-encoded serialized public group state>"
}
```

### Updating the MLS group state

The MLS group state can be updated by sending an MLS commit.  The commit is
constructed and sent as follows:

* determine the base epoch and resolve any extremities, as defined by DMLS
* add any new devices that are in the room (fetching their InitKeys), and
  remove devices that are no longer in the room
* create the new epoch and the MLS commit as described in the MLS spec,
  resulting in an MLS ciphertext, and an MLS welcome message for the new
  devices
* encode the MLS ciphertext and MLS welcome message using the serialization
  defined in MLS
* look up the event ID for the commit that created the base epoch
* construct and send a Matrix event of type `m.room.encrypted`, with contents
  of the form:

  ```json
  {
    "algorithm": "m.dmls.v1.[ciphersuite]",
    "ciphertext": "<base64-encoded serialized MLS ciphertext>",
    "epoch_creator": ["<base epoch creator's user ID>", "<base epoch creator's device ID>"],
    "sender": ["<user ID>", "<device ID> "],
    "resolves": [/* list of ["<epoch number>", ["<epoch creator user ID>", "epoch creator device ID"]] */],
    "commit_event": "<event ID for the base epoch's commit event>",
    "public_group_state": "<base64-encoded serialized public group state>"
  }
  ```

  and remember the event ID, where `resolves` is a list of the epochs that the
  commit resolves.  \[TODO: determine how identity is represented.  In here, we
  use a tuple (represented as an array) of the user's ID and device ID.  In the
  draft implementation, we concatenate the user ID and device ID, separated by
  a `|`, as that is how identity is represented (see the Credentials section
  above).\] If the base epoch is the initial epoch, then the `commit_event`
  property should be set to the event ID of the `m.room.create` event.
* send to-device messages to all new devices with type `m.room.encrypted`
  and with the form:

  ```json
  {
    "algorithm": "m.mls.v1.welcome.[ciphersuite]",
    "ciphertext": "<base64-encoded serialized welcome message>",
    "room_id": "<room ID>",
    "sender": ["<user ID>", "<device ID>"],
    "resolves": [/* list of ["<epoch number>", ["<epoch creator user ID>", "epoch creator "]],
                    where the first item is the base epoch */],
    "commit_event": "<event ID of the Matrix event sent above>"
  }
  ```

When a device receives and decrypts a commit message, it remembers the event ID
and associates it with the new epoch, for later lookup.  Similarly, when a
device receives and decrypts a Welcome message, it remembers the event ID given
in the message.

\[TODO: If the Welcome message does not contain a copy of the ratchet tree, we
need to add the ratchet tree to the event as another property.\]

\[TODO: Since the event will contain a copy of the ratchet tree (either as part
of the MLS welcome, or as a separate property), this might exceed Matrix's
event size limit, so we may want to use another mechanism to send the ratchet
tree.  Maybe upload it to the media repository?  This could cause things to
fail if the sender's server is down when the recipient processes the welcome
event, so maybe have the recipient server pre-fetch the file when it receives
the welcome event.\]

\[TODO: may need to store `public_group_state` and/or commit `ciphertext` in
media repo if too big.\]

#### External joins

To allow users/devices to join a group and send a message without having
someone else first add them to the group, MLS allows external users to send a
commit using the public group state.  Joining a group in such a way requires
the joiner to be able to fetch the public group state, which is part of the
commit event as described above.

To allow a client to easily obtain the commit event, a new field is added to
the `Filter` object in the `POST /search`: `mls_public_group_state`.  When set
to `true`, the server will search for MLS commit events that have a
`public_group_state` field.  The server will ignore the history visibility
settings of rooms that the user is a member of, and will return events as if
the user were able to view all such events. \[TODO: how do clients detect
support?\] \[NOTE: this is not yet implemented.  Maybe break into a separate
MSC?\]

If the server does not support the `mls_public_group_state` filter, the client
can use the `GET /messages` endpoint to paginate backwards through the messages
to search for an MLS-encrypted event with a `public_group_state`.  However,
this does not work if the room's history visibility settings prevent the user
from seeing these events.

Using the public group state, the client can create an external commit as
described in MLS, and send the commit to the group as described above.

\[TODO: should have a configuration setting that controls whether external
commits are allowed\]

### Messages

Messages are encrypted and sent as follows:

* if there are multiple extremities, resolve them and send the commit event as
  described above
* construct a JSON object of the form:

  ```json
  {
    "type": "<the event type>",
    "content": { /* event contents */ },
    "room_id": "<the room id>"
  }
  ```
* serialize the JSON object as a UTF-8 string
* encrypt the serialized JSON with MLS, resulting in an MLS ciphertext
* encode the MLS ciphertext using the serialization defined in MLS
* look up the event ID for the commit corresponding to the current epoch
  and the epoch creator
* construct and send a Matrix event of type `m.room.encrypted`, with contents
  of the form:

  ```json
  {
    "algorithm": "m.dmls.v1.[ciphersuite]",
    "ciphertext": "<base64-encoded serialized MLS ciphertext>",
    "epoch_creator": ["<epoch creator user ID>", "<epoch creator device ID>"],
    "commit_event": "<event ID for the epoch's commit event>"
  }
  ```

### Room IDs

\[TODO: In MLS, a group is identified by a <256-byte string.  Matrix does not
have a limit on the length of room IDs.  We should probably set a length limit
as other identifiers have a length limit.  We could also use a hash of the room
ID as the MLS group ID.

NOTE: in the current demo implementation, we use the room ID as the group ID.
If we do this, we do not need the `room_id` property in the Welcome message
event.\]

### Key Packages

Clients upload key packages as one-time keys using the `/keys/upload` endpoint,
using an algorithm name of `m.dmls.v1.key_package.[ciphersuite]`.  Key packages
are serialized using the encoding specified in MLS, and then base64-encoded.
For example, a client might upload a key by sending the following body to
`/keys/upload`:

```json
{
  "one_time_keys": {
    "m.dmls.v1.key_package.dhkemx25519-aes128gcm-sha256-ed25519:<key_id>":
        "<base64-encoded serialized key package>"
  }
}
```

Implementations are encouraged to make the `key_id` something unique that is
based on the key package, rather than using an unrelated string.  For example,
it could be the public key, or a hash of the key package.

Note that key packages, as defined in MLS, are signed by the credential, so do
not need additional signing as is done with Olm one-time keys.

\[TODO: KeyPackages have a validity period, so servers will need to be aware of
this and 1) not serve out KeyPackages outside of their validity period, and 2)
drop KeyPackages when they expire.  MLS also has the concept of a "last resort"
InitKey, which maps over to fallback OTKs.\]

## Unstable prefix

Implementations should use the prefix `org.matrix.msc2883.v0.dmls` in place of
`m.dmls.v1` until this lands in a released version of the specification.
